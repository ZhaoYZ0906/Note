一 所求的最长公共前缀子串一定是每个字符串的前缀子串。
    1 将strs【0】赋值给result
    2 用result和strs【0】比较，得出公共部分赋值给result
    3 将strs【1】执行2操作
    4 将strs【2】执行2操作
    5 循环比较直到数组结束
    6 返回result

二 纵向扫描：从下标0开始，判断每一个字符串的下标0，判断是否全部相同。
直到遇到不全部相同的下标。时间性能为O(n*m)。
（console1app使用这种算法）

三 二分法：设立两个下标分别为：left和right
	 设立一个中间值 hiddle=（left+right）/2
	1 取第一个字符串 前hiddle位 赋值给result
	2 使用result和其他字符串比较 直至结束
	3 如果全部相同则表明这一部分为公共前缀，
	   将left=hiddle+1	  否则将 right=hiddle-1
	4 执行第一步直到left>right	
逻辑：这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。
算法的查找区间是 (0 \ldots minLen)(0…minLen)，
其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 
每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。

5、借助trie字典树。将这些字符串存储到trie树中。
那么trie树的第一个分叉口之前的单分支树的就是所求。（没看懂）