场景：
1 快慢指针判断链表是否为环形（有回路）
2 在有序链表中寻找中位数
3  输出链表中的倒数第K个节点(即正数第K-1个节点)
4 判断链表是否存在环，如果存在，找到环入口
5 判断两个单链表是否相交，如果相交，找到他们的第一个公共节点

逻辑1：
如果链表存在环，就好像操场的跑道是一个环形一样。
此时让快慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；
如果快指针到达NULL，说明链表以NULL为结尾，没有环。如果快指针追上慢指针，则表示有环。

逻辑2：
快指针的移动速度是慢指针移动速度的2倍，因此当快指针到达链表尾时，慢指针到达中点。

???
程序还要考虑链表结点个数的奇偶数因素，当快指针移动x次后到达表尾（1+2x），说明链表有奇数个结点，
直接返回慢指针指向的数据即可。

????
如果快指针是倒数第二个结点，说明链表结点个数是偶数，
这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。

逻辑3：
可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；
从第K步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，
当第一个指针到达链表的尾节点时候，第二个指针正好是倒数第K个节点，

逻辑4（没懂为什么但是确实可以用）：
有一个单链表，其中可能有一个环，也就是某个节点的next指向的是链表中在它之前的节点，这样在链表的尾部形成一环。

如何判断一个链表是否存在环？设定两个指针slow，fast，均从头指针开始，每次分别前进1步、2步。
如存在环，则两者相遇；如不存在环，fast遇到NULL退出。

????
如果链表存在环，如果找到环的入口点？当fast若与slow相遇时，slow肯定没有走遍历完链表或者恰好遍历一圈。
于是我们从链表头与相遇点分别设一个指针，每次各走一步，两个指针必定相遇，且相遇第一点为环入口点。

逻辑5（没看懂）：
(1)如果都不存在环，则如果两个单向链表有公共节点，也就是两个链表从某一节点开始，他们的p_next都指向同一个节点，
每个节点只有一个p->next。因此从第一个公共节点开始，之后它们所有节点都是重合的。
因此，首先两个链表各遍历一次，求出两个链表的长度L1、L2，然后可以得到它们的长度差L。
然后现在长的链表上遍历L个节点，之后再同步遍历，于是在遍历中，第一个相同的节点就是第一个公共的节点。
此时，若两个链表长度分别为M，N,则时间复杂度为O(M+N).

? ? ?
(2)如果一个存在环，另外一个不存在环，则这两个链表是不可能相交的。

? ? ?
(3)如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个节点，在不在另外一个链表上，
如果在，则相交，不在，则不相交。


