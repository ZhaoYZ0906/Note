设置哨兵是为了减少比较次数，省去对下标越界的判断。
应用：假设一个乱序数组，需要查找一个元素是否在该数组中，这时需要用到顺序查找，也就是遍历数组。
一般情况下我们会写下如下代码：
int Sequential_Search(int *a,int n,int key)  
{  
    //数组从1开始  
    int i;  
    for(int i=1;i<=n;i++)  
    {  
        if(a[i]==key)  
            return i;  
    }  
    return 0;//查找失败  
}  
有的数据结构书上，会运用哨兵元素，改成这样的代码：
int Sequential_Search2(int *a int n,int key)  
{  
    int i=0;  
    a[0]=key;//哨兵  
    i=n;  
    while(a[i]!=key)  
    {  
        i--;  
    }  
    return i;//返回0就是查找失败  
}  
仔细看来没有什么差别，但是来看下我测试的运行时间，数组有10亿个元素。
方案1：3.494s   3.202s   3.216s   3.237s

方案2：2.332s   2.307s   2.24s   2.194s
循环中，方案1有3条指令而方案2有两条指令，少了i<n这个比较操作，所以方案2性能得到了提升，这也是哨兵元素的妙用
“这种查找方法在查找方向的尽头设置哨兵元素，免去了查找过程中每次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但是总数据较多时，效率提高很明显，是非常好的编程技巧。

