delegate类（委托）
核心作用：为一个方法成为另一个方法的参数提供了可能
定义：
委托是一种引用类型，它是函数指针的托管版本。
在C#中，委托是一种可以把引用存储为函数的类型。
委托可以引用实例和静态方法，而函数指针只能引用静态方法。
委托的声明非常类似于函数，和函数不同的的是委托不带函数体，并且需要Delegate关键字。
委托的声明指定了一个函数签名，其中包含参数列表和和一个返回类型。
在定义了委托后，就可以声明该委托类型的变量，然后可以将这个变量初始化为与该委托有相同签名的函数进行引用，随后可以使用委托变量调用该函数。
（ps：其实委托他丫的就是一个类，他的目的就是将方法可以作为其他方法的参数传递！）

委托的定义（与定义一个方法差不多，权限+delegate+返回值+名称+参数列表+；）：
定义委托基本上就是定义一个新类，所以可以在定义类的任何相同地方定义委托。
可以在委托定义上应用常见的访问修饰符：public、private、protected等。其访问作用域也雷同于类。


系统有两个已经定义的委托类 func<t>和active<t>
fun为有返回值，active为无返回值，返回值与参数类型在泛型里面定义，最多好像支持11个参数，足够用

委托实例化+初始化：
委托类名 实例名=实例对象/静态类.方法（）；
委托类名 实例名=匿名方法（）；//匿名方法使用的非常少，一般直接lambda
委托类名 实例名=lambda
第1 3种非常常用。
当使用实例对象的时候，委托变量的target属性为提供方法的对象
当使用静态类的时候，委托变量的target属性为null


委托调用
委托实例（参数）；

多播委托
一个委托实例通过+=的方式存放1-n个方法当调用委托变量时则调用存储的多个方法称为多播委托
注意：
1、多播委托包含一个以上方法的引用且必须是同类型的
2、多播委托包含的方法必须返回void，否则会抛出run-time exception，并且不能带参数（但可以带引用参数）


一般来说委托都与lambda配合使用，但在使用时要注意闭包问题（语法使用方法与注意事项中有）



事件是委托的一个实例

事件的定义 初始化 使用 赋值

        class Judgment
     { 
         //定义一个委托
         public delegate void delegateRun();
         //定义一个事件
         public event delegateRun eventRun;
         //引发事件的方法
         public void Begin()
         {
             eventRun();//被引发的事件
         } 
     }
     class RunSports
     { 
         //定义事件处理方法
         public void Run()
         {
             Console.WriteLine("运动员开始比赛");
         }
     }
     class Program
     {
         static void Main(string[] args)
         {
             RunSports runsport = new RunSports();//实例化事件发布者
             Judgment judgment = new Judgment();//实例化事件订阅者
             //订阅事件
             judgment.eventRun+=new Judgment.delegateRun(runsport.Run);
             //引发事件
             judgment.Begin();
             Console.ReadKey();
         }
     }


委托与事件的对比：
委托是一个类型
事件是委托的一个实例，必须在类内实例化

委托可以使用+=，-=，=进行赋值操作（使用=，则=之前的赋值全部清空）
委托可以在外面直接调，比如 类名.委托变量（）

事件只可以使用+=，-=进行赋值操作
事件在外面不能直接调用，只能在类内进行调用，所以类要给事件一个调用的方法一般










